/***************************************************************************
 ** This file is part of the generic algorithm library Wiselib.           **
 ** Copyright (C) 2008,2009 by the Wisebed (www.wisebed.eu) project.      **
 **                                                                       **
 ** The Wiselib is free software: you can redistribute it and/or modify   **
 ** it under the terms of the GNU Lesser General Public License as        **
 ** published by the Free Software Foundation, either version 3 of the    **
 ** License, or (at your option) any later version.                       **
 **                                                                       **
 ** The Wiselib is distributed in the hope that it will be useful,        **
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of        **
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
 ** GNU Lesser General Public License for more details.                   **
 **                                                                       **
 ** You should have received a copy of the GNU Lesser General Public      **
 ** License along with the Wiselib.                                       **
 ** If not, see <http://www.gnu.org/licenses/>.                           **
 ***************************************************************************/

#ifndef __PLTT_PASSIVE_H__
#define __PLTT_PASSIVE_H__
#include "PLTT_config.h"
#include "PLTT_message.h"
namespace wiselib
{
	template<	typename Os_P,
				typename Node_P,
				typename PLTT_Node_P,
				typename PLTT_NodeList_P,
				typename PLTT_Trace_P,
				typename PLTT_TraceList_P,
				typename PLTT_Agent_P,
				typename PLTT_AgentList_P,
				typename NeighborDiscovery_P,
				typename Timer_P,
				typename Radio_P,
				typename Rand_P,
				typename Clock_P,
				typename PLTT_SpreadMetrics_P,
				typename PLTT_TrackMetrics_P,
				typename Debug_P>
	class PLTT_PassiveType
	{
	public:
		typedef Os_P Os;
		typedef Radio_P Radio;
		typedef Rand_P Rand;
		typedef typename Rand::rand_t rand_t;
		typedef Debug_P Debug;
		typedef Node_P Node;
		typedef PLTT_Agent_P PLTT_Agent;
		typedef PLTT_AgentList_P PLTT_AgentList;
		typedef typename PLTT_Agent::AgentID AgentID;
		typedef typename PLTT_AgentList::iterator PLTT_AgentListIterator;
		typedef PLTT_Node_P PLTT_Node;
		typedef PLTT_NodeList_P PLTT_NodeList;
		typedef typename PLTT_NodeList::iterator PLTT_NodeListIterator;
		typedef PLTT_Trace_P PLTT_Trace;
		typedef typename PLTT_Trace::PLTT_TraceData PLTT_TraceData;
		typedef PLTT_TraceList_P PLTT_TraceList;
		typedef typename PLTT_TraceList::iterator PLTT_TraceListIterator;
		typedef typename Node::Position Position;
		typedef typename Node::Position::CoordinatesNumber CoordinatesNumber;
		typedef typename PLTT_Node::PLTT_NodeTarget PLTT_NodeTarget;
		typedef typename PLTT_NodeTarget::IntensityNumber IntensityNumber;
		typedef typename PLTT_Node::PLTT_NodeTargetList PLTT_NodeTargetList;
		typedef typename PLTT_Node::PLTT_NodeTargetListIterator PLTT_NodeTargetListIterator;
		typedef NeighborDiscovery_P NeighborDiscovery;
		typedef Timer_P Timer;
		typedef Clock_P Clock;
		typedef PLTT_SpreadMetrics_P PLTT_SpreadMetrics;
		typedef PLTT_TrackMetrics_P PLTT_TrackMetrics;
		typedef typename Radio::node_id_t node_id_t;
		typedef typename Radio::size_t size_t;
		typedef typename Radio::block_data_t block_data_t;
		typedef typename Radio::message_id_t message_id_t;
		typedef typename Radio::ExtendedData ExtendedData;
		typedef typename Timer::millis_t millis_t;
		typedef wiselib::vector_static<Os, Node, 10> NodeList;
		typedef typename NodeList::iterator NodeList_Iterator;
		typedef PLTT_MessageType<Os, Radio> Message;
		typedef PLTT_PassiveType<Os, Node, PLTT_Node, PLTT_NodeList, PLTT_Trace, PLTT_TraceList, PLTT_Agent, PLTT_AgentList, NeighborDiscovery, Timer, Radio, Rand, Clock, PLTT_SpreadMetrics, PLTT_TrackMetrics, Debug> self_type;
		// -----------------------------------------------------------------------
		PLTT_PassiveType()
		: 	radio_callback_id_  ( 0 ),
		  	seconds_counter		( 1 )
		{}
		// -----------------------------------------------------------------------
		~PLTT_PassiveType()
		{}
		// -----------------------------------------------------------------------
		void enable( void )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_MISC
			debug().debug( "PLTT_Passive %x: Boot \n", self.get_node().get_id() );
			#endif
			radio().enable_radio();
			radio_callback_id_ = radio().template reg_recv_callback<self_type, &self_type::receive>( this );
			millis_t r = rand()()%2000;
			timer().template set_timer<self_type, &self_type::neighbor_discovery_enable_task>( r, this, 0);
			update_traces();
		}
		void neighbor_discovery_enable_task( void* userdata = NULL)
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_NEIGHBORHOOD_DISCOVERY
			debug().debug( "PLTT_Passive %x: Neighbor discovery enable task \n", self.get_node().get_id() );
			#endif
			block_data_t buff[Radio::MAX_MESSAGE_LENGTH];
			self.get_node().get_position().set_buffer_from( buff );
			uint8_t flags = NeighborDiscovery::NEW_PAYLOAD_BIDI | NeighborDiscovery::DROPPED_NB;
			neighbor_discovery().init( radio(), clock(), timer(), debug() );
			neighbor_discovery().enable();
			neighbor_discovery().template reg_event_callback<self_type, &self_type::sync_neighbors>( 2, flags, this );
			neighbor_discovery().set_payload( 2, buff, self.get_node().get_position().get_buffer_size() );
			timer().template set_timer<self_type, &self_type::neighbor_discovery_unregister_task>( 30000, this, 0);
		}
		// -----------------------------------------------------------------------
		void neighbor_discovery_unregister_task( void* userdata = NULL)
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_NEIGHBORHOOD_DISCOVERY
			debug().debug( "PLTT_Passive %x: Neighbor discovery unregister task \n", self.get_node().get_id() );
			#endif
			neighbor_discovery().unreg_event_callback( 2 );
			neighbor_discovery().unregister_payload_space( 2 );
			neighbor_discovery().disable();
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_NEIGHBORHOOD_DISCOVERY
			print_neighbors();
			#endif
		}
		// -----------------------------------------------------------------------
		void disable( void )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_MISC
			debug().debug( "PLTT_Passive %x: Disable \n", self.get_node().id );
			#endif
			radio().unreg_recv_callback( radio_callback_id_ );
			radio().disable();
		}
		// -----------------------------------------------------------------------
		void send( node_id_t destination, size_t len, block_data_t *data, message_id_t msg_id )
		{
			Message message;
			message.set_msg_id( msg_id );
			message.set_payload( len, data );
			radio().send( destination, message.buffer_size(), ( uint8_t* )&message );
		}
		// -----------------------------------------------------------------------
		void receive( node_id_t from, size_t len, block_data_t *data, const ExtendedData& exdata )
		{
			message_id_t msg_id = *data;
			Message *message = ( Message* )data;
			if ( msg_id == PLTT_SPREAD_ID )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Received spread message from %x of link metric %i and size %i \n", self.get_node().get_id(), from, exdata.link_metric(), len );
				#endif
				prepare_spread_trace( store_trace( PLTT_Trace( message->payload() ) ), exdata );
			}
			else if ( msg_id == PLTT_INHIBITION_MESSAGE_ID )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
				debug().debug( "PLTT_Passive %x: Received inhibition message from %x of size %i and payload size of %i \n", self.get_node().get_id(), from, len, message->payload_size() );
				#endif
				inhibit_traces( update_neighbor( PLTT_Node( message->payload() ) ), from );
			}
			else if ( msg_id == PLTT_TRACK_ECHO_ID )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_ECHO
				AgentID aid = read<Os, block_data_t, AgentID>( message->payload() );
				debug().debug( "PLTT_Passive %x: Received track echo message %x from %x of size %i and payload size of %i \n", self.get_node().get_id(), aid, from, len, message->payload_size() );
				#endif
				send( from, message->payload_size(), message->payload(), PLTT_TRACK_ECHO_REPLY_ID );
			}
			else if ( msg_id == PLTT_QUERY_ID )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
				debug().debug( "PLTT_Passive %x: Received query agent message from %x of size %i and payload size of %i \n", self.get_node().get_id(), from, len, message->payload_size() );
				#endif
				timer().template set_timer<self_type, &self_type::process_query>( 20, this, (void*) store_query_agent( PLTT_Agent( message->payload() ) ) );
			}
			else if (msg_id == PLTT_QUERY_REPORT_ID)
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
				debug().debug( "PLTT_Passive %x: Received report agent message from %x of size %i and payload size of %i \n", self.get_node().get_id(), from, len, message->payload_size() );
				#endif
				timer().template set_timer<self_type, &self_type::process_query_report>( 20, this, (void*) store_report_agent( PLTT_Agent( message->payload() ) ) );
			}
		}
		// -----------------------------------------------------------------------
		PLTT_Trace* store_trace( PLTT_Trace t )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
			debug().debug( "PLTT_Passive %x: Store trace\n", self.get_node().get_id() );
			#endif
			PLTT_TraceListIterator traces_iterator = traces.begin();
			while ( traces_iterator!=traces.end() )
			{
				if ( traces_iterator->get_target_id() == t.get_target_id() )
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Store trace - new trace intensity and start time (%i, %i ) vs current (%i, %i, %i) ", self.get_node().get_id(), t.get_intensity(), t.get_start_time(), traces_iterator->get_intensity(), traces_iterator->get_start_time(), traces_iterator->get_inhibited() );
					#endif
					#ifdef OPT_NON_MERGED_TREE
					if   ( traces_iterator->get_intensity() <= t.get_intensity() &&
						  t.get_start_time() != traces_iterator->get_start_time() )
					#else
					if   ( traces_iterator->get_intensity() <= t.get_intensity() )
					#endif
					{
						*traces_iterator = t;
						traces_iterator->update_path( self.get_node() );
						//self.set_node_target_list( traces );
						return &( *traces_iterator );
					}
					else
					{
						return NULL;
					}
				}
				++traces_iterator;
			}
			t.update_path( self.get_node() );
			traces.push_back( t );
			//self.set_node_target_list( traces );
			traces_iterator = traces.end() - 1;
			return &( *traces_iterator );
		}
		// -----------------------------------------------------------------------
		void update_traces( void* userdata = NULL )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_MISC
			debug().debug( "PLTT_Passive %x: Update Traces trace", self.get_node().get_id() );
			#endif
			for ( PLTT_TraceListIterator traces_iterator = traces.begin(); traces_iterator != traces.end(); ++traces_iterator )
			{
				if ( ( seconds_counter % traces_iterator->get_diminish_seconds() == 0) && ( traces_iterator->get_inhibited() != 0 ) )
				{
					traces_iterator->update_intensity_diminish();
					if ( traces_iterator->get_intensity() == 0 )
					{
						traces_iterator->set_inhibited();
					}
				}
			}
			seconds_counter++;
			timer().template set_timer<self_type, &self_type::update_traces>( 1000, this, 0 );
			//self.set_node_target_list( traces );
		}
		// -----------------------------------------------------------------------
		void print_traces( void* userdata = NULL )
		{
			debug().debug( "PLTT_Passive %x: Traces start print-out\n", self.get_node().id );
			for ( PLTT_TraceListIterator traces_iterator = traces.begin(); traces_iterator != traces.end(); ++traces_iterator )
			{
				traces_iterator->print_trace( debug() );
				debug().debug( "-----------------------------\n");
			}
			debug().debug( "PLTT_Passive %x: Traces end print-out \n", self.get_node().get_id() );
			timer().template set_timer<self_type, &self_type::print_traces>( 11000, this, 0);
		}
		// -----------------------------------------------------------------------
		void prepare_spread_trace( PLTT_Trace* t, const ExtendedData& exdata)
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
			debug().debug( "PLTT_Passive %x: Prepare Spread Trace\n", self.get_node().get_id() );
			#endif
			if (t != NULL )
			{
				NodeList recipient_candidates;
				Node rep_point = ( *t ).get_repulsion_point();
				for ( PLTT_NodeListIterator neighbors_iterator = neighbors.begin(); neighbors_iterator != neighbors.end(); ++neighbors_iterator )
				{
					if ( rep_point.get_id() != 0 )
					{
						if ( rep_point.get_position().distsq( self.get_node().get_position() ) <= rep_point.get_position().distsq( neighbors_iterator->get_node().get_position() ) )
						{
							recipient_candidates.push_back( neighbors_iterator->get_node() );
						}
					}
				}
				millis_t r = rand()()%400;
				#ifdef OPT_LQI_INHIBITION
				if (exdata.link_metric() / 257 != 0 )
				{
					debug().debug( "PLTT_Passive %x: Prepare Spread - Has lqi of %i\n", self.get_node().get_id(), exdata.link_metric() );
					r = 20000 / ( exdata.link_metric() / 257 ) + r;
				}
				#endif
				if ( recipient_candidates.size() == 0 )
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Prepare Spread - Exited due to 0 element candidate list\n", self.get_node().get_id() );
					#endif
					t->set_inhibited();
					return;
				}
				else if ( recipient_candidates.size() == 1 )
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Prepare Spread - Candidate list of size 1 - Imposing 1000ms delay\n", self.get_node().get_id() );
					#endif
					r = r + 1000;
				}
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Prepare Spread - Scheduled inhibition and spread in %i millis \n", self.get_node().get_id(), r );
				#endif
				timer().template set_timer<self_type, &self_type::send_inhibition> ( r, this, ( void* )t);
				timer().template set_timer<self_type, &self_type::spread_trace> ( r + 100, this, ( void* )t );
			}
			else
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Prepared Spread - Exited due to ignore from store\n", self.get_node().get_id() );
				#endif
			}
		}
		// -----------------------------------------------------------------------
		void spread_trace( void* userdata )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
			debug().debug( "PLTT_Passive %x: Spread Trace\n", self.get_node().get_id() );
			#endif
			PLTT_Trace* t = ( PLTT_Trace* )userdata;
			if ( ( *t ).get_inhibited() == 0 )
			{
				typedef wiselib::vector_static<Os, Node, 10> NodeList;
				typedef typename NodeList::iterator NodeList_Iterator;
				NodeList recipient_candidates;
				NodeList_Iterator recipient_candidates_iterator;
				#ifndef OPT_SPREAD_RANDOM_RECEIVERS
				NodeList_Iterator recipient_candidates_iterator_buff;
				CoordinatesNumber d = 0;
				uint8_t found = 0;
				#endif
				Node rep_point = ( *t ).get_repulsion_point();
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Spread Trace - Neighbor list of size %i \n", self.get_node().get_id(), neighbors.size() );
				#endif
				for ( PLTT_NodeListIterator neighbors_iterator = neighbors.begin(); neighbors_iterator != neighbors.end(); ++neighbors_iterator )
				{
					if ( rep_point.get_id() != 0 )
					{
						if ( rep_point.get_position().distsq( self.get_node().get_position() ) <= rep_point.get_position().distsq( neighbors_iterator->get_node().get_position() ) )
						{
							recipient_candidates.push_back( neighbors_iterator->get_node() );
						}
					}
				}
				#ifdef OPT_SPREAD_RANDOM_RECEIVERS
				if ( recipient_candidates.size() !=0 )
				{
					( *t ).update_intensity_penalize();
					rand_t rand_elem = rand()() % recipient_candidates.size();
					node_id_t rand_id = recipient_candidates.at( rand_elem ).get_id();
					( *t ).set_furthest_id( rand_id );
					recipient_candidates.erase( recipient_candidates.begin() + rand_elem );
					size_t len = ( *t ).get_buffer_size();
					block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
					block_data_t* buff = buf;
					buff = ( *t ).set_buffer_from( buff );
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Spread Trace - To random1\n", self.get_node().get_id() );
					#endif
					send((*t).get_furthest_id(), len, (uint8_t*)buff, PLTT_SPREAD_ID );
				}
				#else
				for ( recipient_candidates_iterator = recipient_candidates.begin(); recipient_candidates_iterator != recipient_candidates.end(); ++recipient_candidates_iterator )
				{
					CoordinatesNumber cand_d = rep_point.get_position().distsq( recipient_candidates_iterator->get_position() );
					if (cand_d > d)
					{
						d = cand_d;
						recipient_candidates_iterator_buff = recipient_candidates_iterator;
						found = 1;
					}
				}
				if ( found == 1 )
				{
					( *t ).update_intensity_penalize();
					( *t ).set_furthest_id( recipient_candidates_iterator_buff->get_id() );
					recipient_candidates.erase( recipient_candidates_iterator_buff );
					size_t len = ( *t ).get_buffer_size();
					block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
					block_data_t* buff = buf;
					buff = ( *t ).set_buffer_from( buff );
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Spread Trace - To furthest \n", self.get_node().get_id() );
					#endif
					send( ( *t ).get_furthest_id(), len, ( uint8_t* )buff, PLTT_SPREAD_ID );
				}
				#endif
				if ( recipient_candidates.size() !=0 )
				{
					( *t ).set_random_id( recipient_candidates.at( rand()()% recipient_candidates.size() ).get_id() );
					size_t len = ( *t ).get_buffer_size();
					block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
					block_data_t* buff = buf;
					buff = ( *t ).set_buffer_from( buff );
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
					debug().debug( "PLTT_Passive %x: Spread Trace - To random2\n", self.get_node().get_id() );
					#endif
					send((*t).get_random_id(), len, (uint8_t*)buff, PLTT_SPREAD_ID );
				}
				( *t ).set_inhibited();
			}
			else
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Spread Trace - Exited due to inhibition\n", self.get_node().get_id() );
				#endif
			}
		}
		// -----------------------------------------------------------------------
		void send_inhibition( void* userdata = NULL )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
			debug().debug( "PLTT_Passive %x: Entered Send Neighbor Inhibition Discovery Message\n", self.get_node().get_id() );
			#endif
			PLTT_Trace* t = (PLTT_Trace*)userdata;
			if ( ( *t ).get_inhibited() == 0 )
			{
				#ifdef OPT_TARGET_LIST_AGGREGATION
				self.set_node_target_list(traces);
				#else
				self.set_node_target( traces, ( *t ).get_target_id() );
				#endif
				size_t len = self.get_buffer_size();
				block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
				block_data_t* buff = buf;
				self.set_buffer_from( buff );
				send( Radio::BROADCAST_ADDRESS, len, (uint8_t*)buff, PLTT_INHIBITION_MESSAGE_ID );
			}
			else
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_SPREAD
				debug().debug( "PLTT_Passive %x: Exited Send Neighbor Inhibition Discovery due to inhibition\n", self.get_node().get_id() );
				#endif
			}
		}
		//------------------------------------------------------------------------
		PLTT_Node* update_neighbor( PLTT_Node n )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
			debug().debug( "PLTT_Passive %x: Update Neighbor\n", self.get_node().get_id() );
			#endif
			PLTT_NodeListIterator i = neighbors.begin();
			while ( i != neighbors.end() )
			{
				if ( i->get_node().get_id() == n.get_node().get_id() )
				{
					*i = n;
					return &( *i );
				}
				++i;
			}
			neighbors.push_back( n );
			i = neighbors.end() - 1;
			return &( *i );

		}
		// -----------------------------------------------------------------------
		PLTT_Agent* store_report_agent( PLTT_Agent _agent )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
			debug().debug( "PLTT_Passive %x: Store report agent\n", self.get_node().get_id() );
			#endif
			PLTT_AgentListIterator i = report_agents.begin();
			while ( i != report_agents.end() )
			{
				if ( i->get_tracker().get_id() == _agent.get_tracker().get_id() )
				{
					*i = _agent;
					return &( *i );
				}
				++i;
			}
			report_agents.push_back( _agent );
			i = report_agents.end() - 1;
			return &( *i );
		}
		// -----------------------------------------------------------------------
		PLTT_Agent* store_query_agent( PLTT_Agent _agent )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
			debug().debug( "PLTT_Passive %x: Store track query\n", self.get_node().get_id() );
			#endif
			PLTT_AgentListIterator i = query_agents.begin();
			while ( i != query_agents.end() )
			{
				if ( i->get_tracker().get_id() == _agent.get_tracker().get_id() )
				{
					*i = _agent;
					return &( *i );
				}
				++i;
			}
			query_agents.push_back( _agent );
			i = query_agents.end() - 1;
			return &( *i );
		}
		// -----------------------------------------------------------------------
		void print_neighbors( void* userdata = NULL )
		{
			debug().debug( "PLTT_Passive %x: Begin neighbors printout\n", self.get_node().get_id() );
			self.print( debug() );
			for ( PLTT_NodeListIterator i = neighbors.begin(); i != neighbors.end(); ++i )
			{
				i->print( debug() );
			}
			debug().debug( "\nPLTT_Passive %x: End neighbors printout\n", self.get_node().get_id() );
			//timer().template set_timer<self_type, &self_type::print_neighbors>( 10000, this, 0);
		}
		// -----------------------------------------------------------------------
		void inhibit_traces( PLTT_Node* n, node_id_t nid)
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
			debug().debug( "PLTT_Passive %x: Inhibit traces\n", self.get_node().get_id() );
			#endif
			if ( n != NULL )
			{
				for ( PLTT_TraceListIterator i = traces.begin(); i != traces.end(); ++i )
				{
					for (PLTT_NodeTargetListIterator j = n->get_node_target_list()->begin(); j != n->get_node_target_list()->end(); ++j )
					{
						#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
						debug().debug(" PLTT_Passive %x: Inhbit traces - Has trace of %i intensity vs %i \n", self.get_node().get_id(), i->get_intensity(), j->get_intensity() );
						#endif
						if ( ( i->get_inhibited() == 0 ) &&
							 ( j->get_target_id() == i->get_target_id()  &&
							 ( j->get_intensity() >=  i->get_intensity() ) ) )
						{
							#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
							debug().debug(" PLTT_Passive %x: Inhibit traces - Has trace of %i inhibited\n", self.get_node().get_id(), i->get_target_id() );
							#endif
							i->set_inhibited();
							#ifdef OPT_PATH_CORRECTION
							i->update_intensity_penalize();
							i->set_current( n->get_node() );
							i->set_parent( n->get_node() );
							i->set_grandparent( n->get_node() );
							#endif
						}
					}
				}
			}
			else
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_INHIBITION
				debug().debug( "PLTT_Passive %x: Inhibit traces - Exited due to NULL\n", self.get_node().get_id() );
				#endif
			}
			//self.set_node_target_list( traces );
		}
		// -----------------------------------------------------------------------
		PLTT_Trace* find_trace( node_id_t nid )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_MISC
			debug().debug( "PLTT_Passive %x: Find trace\n", self.get_node().get_id() );
			#endif
			for ( PLTT_TraceListIterator i = traces.begin(); i != traces.end(); ++i )
			{
				if ( nid == i->get_target_id() )
				{
					return &( *i );
				}
			}
			return NULL;
		}
		// -----------------------------------------------------------------------
		void process_query( void* userdata = NULL)
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
			debug().debug( "PLTT_Passive %x: Process query\n", self.get_node().get_id() );
			#endif
			PLTT_Agent* agent = ( PLTT_Agent* ) userdata;
			block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
			block_data_t* buff = buf;
			agent->set_buffer_from( buff );
			PLTT_Trace* trace_of_target = find_trace( agent->get_target().get_id() );
			if ( trace_of_target != NULL )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
				debug().debug( "PLTT_Passive %x: Process query - Trace of target %x found with intensity %i vs max_intensity %i !\n", self.get_node().get_id(), agent->get_target().get_id(), trace_of_target->get_intensity(), agent->get_max_intensity() );
				#endif
				//if ( ( agent->get_max_intensity() - trace_of_target->get_intensity() ) <= trace_of_target->get_spread_penalty() )
				if ( ( trace_of_target->get_intensity() * 100 ) / agent->get_max_intensity() >= 90 ) //TO DO - 90 SHOULD BE PARAMETERIZED AS TRACKINT_INTENSITY_THRESHOLD
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
					debug().debug( "PLTT_Passive %x: Process query - The target is in the area with intensity %i report back!\n", self.get_node().get_id(), trace_of_target->get_intensity() );
					#endif
					agent->set_target( Node( agent->get_target().get_id(), self.get_node().get_position() ) );
					agent->set_buffer_from( buff );
					PLTT_Trace* trace_of_tracker = find_trace( agent->get_tracker().get_id() );
					if ( trace_of_tracker != NULL )
					{
						#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
						debug().debug( "PLTT_Passive %x: Process query - Trace of tracker %x found with intensity %i vs max_intensity %i\n", self.get_node().get_id(), agent->get_tracker().get_id(), trace_of_tracker->get_intensity(), agent->get_max_intensity() );
						#endif
						if ( ( ( agent->get_max_intensity() - trace_of_tracker->get_intensity() ) <= trace_of_tracker->get_spread_penalty() ) && ( trace_of_tracker->get_parent().get_id() == self.get_node().get_id() ) )
						{
							#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
							debug().debug( "PLTT_Passive %x: Process query - The tracker is in the area with intensity %i report back to him!\n", self.get_node().get_id(), trace_of_tracker->get_intensity() );
							#endif
							send( agent->get_tracker().get_id(), agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
							return;
						}
						#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
						debug().debug( "PLTT_Passive %x: Process query - Looking for the tracker following his gradient to recipient %x\n", self.get_node().get_id(), trace_of_tracker->get_parent().get_id() );
						#endif
						send( trace_of_tracker->get_parent().get_id(), agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
						return;
					}
					if ( neighbors.size() != 0 )
					{
						node_id_t nn = neighbors.at( rand()() % neighbors.size() ).get_node().get_id();
						#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
						debug().debug( "PLTT_Passive %x: Process query - Looking for the tracker to the unknown %x\n", self.get_node().get_id(), nn );
						#endif
						send( nn, agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
						return;
					}
					else
					{
						#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
						debug().debug( "PLTT_Passive %x: Process query - No neighbors node while looking for tracker %x\n", self.get_node().get_id() );
						#endif
						return;
					}
				}
				else
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
					debug().debug( "PLTT_Passive %x: Process query - Looking for the target following his gradient to recipient %x\n", self.get_node().get_id(), trace_of_target->get_parent().get_id() );
					#endif
					send( trace_of_target->get_parent().get_id(), agent->get_buffer_size(), buff, PLTT_QUERY_ID );
					return;
				}
			}
			else
			{
				if ( neighbors.size() != 0 )
				{
					node_id_t nn = neighbors.at( rand()() % neighbors.size() ).get_node().get_id();
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
					debug().debug( "PLTT_Passive %x: Process query - Looking for the target to the unknown %x with neighlist size: %i\n", self.get_node().get_id(), nn, neighbors.size() );
					#endif
					send( nn , agent->get_buffer_size(), buff, PLTT_QUERY_ID );
				}
				else
				{
					#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY
					debug().debug( "PLTT_Passive %x: Process query - No neighbors node while looking for target\n", self.get_node().get_id() );
					#endif
				}
			}
		}
		// -----------------------------------------------------------------------
		void process_query_report( void* userdata = NULL )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
			debug().debug( "PLTT_Passive %x: Process query report\n", self.get_node().get_id() );
			#endif
			PLTT_Agent* agent = ( PLTT_Agent* ) userdata;
			debug().debug( "The track_report is valid:\n" );
			block_data_t buf[Radio::MAX_MESSAGE_LENGTH];
			block_data_t* buff = buf;
			agent->set_buffer_from( buff );
			PLTT_Trace* trace_of_tracker = find_trace( agent->get_tracker().get_id() );
			if ( trace_of_tracker != NULL )
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
				debug().debug( "PLTT_Passive %x: Process query report - Trace of tracker %x found with intensity %i vs max_intensity %i\n", self.get_node().get_id(), agent->get_tracker().get_id(), trace_of_tracker->get_intensity(), agent->get_max_intensity() );
				#endif
				//if ( ( agent->get_max_intensity() - trace_of_tracker->get_intensity() ) <= trace_of_tracker->get_spread_penalty() )
				if ( ( trace_of_tracker->get_intensity() * 100 ) / agent->get_max_intensity() >= 90 )
				{
					send( agent->get_tracker().get_id(), agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
					return;
				}
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
				debug().debug( "PLTT_Passive %x: Process query report - Looking for the tracker following his gradient to recipient %x\n", self.get_node().get_id(), trace_of_tracker->get_parent().get_id() );
				#endif
				send( trace_of_tracker->get_parent().get_id(), agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
				return;
			}
			if ( neighbors.size() != 0 )
			{
				node_id_t nn = neighbors.at( rand()() % neighbors.size() ).get_node().get_id();
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
				debug().debug( "PLTT_Passive %x: Process query report - Looking for the tracker to the unknown %x with neighlist size: %i\n", self.get_node().get_id(), nn, neighbors.size() );
				#endif
				send( nn, agent->get_buffer_size(), buff, PLTT_QUERY_REPORT_ID );
			}
			else
			{
				#ifdef ISENSE_PLTT_PASSIVE_DEBUG_TRACK_QUERY_REPORT
				debug().debug( "PLTT_Passive %x: Process query report - No neighbors node while looking for tracker\n", self.get_node().get_id() );
				#endif
			}
		}
		// -----------------------------------------------------------------------
		void sync_neighbors( uint8_t event, node_id_t from, uint8_t len, uint8_t* data )
		{
			#ifdef ISENSE_PLTT_PASSIVE_DEBUG_NEIGHBORHOOD_DISCOVERY
			debug().debug( "PLTT_Passive %x: Sync neighbors\n", self.get_node().get_id() );
			#endif
			if (event == NeighborDiscovery::DROPPED_NB )
			{
				PLTT_NodeListIterator i = neighbors.begin();
				while ( i != neighbors.end() )
				{
					if ( i->get_node().get_id() == from )
					{
						neighbors.erase( i );
						return;
					}
					++i;
				}
			}
			else if (event == NeighborDiscovery::NEW_PAYLOAD_BIDI )
			{
				PLTT_NodeListIterator i = neighbors.begin();
				while ( i != neighbors.end() )
				{
					if ( i->get_node().get_id() == from )
					{
						Position p;
						p.get_from_buffer( data );
						i->get_node().set_position( p );
						return;
					}
					++i;
				}
				Position p;
				p.get_from_buffer( data );
				Node n = Node( from , p );
				neighbors.push_back( PLTT_Node( n ) );
			}
		}
		void init( Radio& radio, Timer& timer, Debug& debug, Rand& rand, Clock& clock, NeighborDiscovery& neighbor_discovery )
		{
			radio_ = &radio;
			timer_ = &timer;
			debug_ = &debug;
			rand_ = &rand;
			clock_ = &clock;
			neighbor_discovery_ = &neighbor_discovery;
		}
		void destruct()
		{}
		PLTT_NodeList* get_neighbors()
		{
			return &neighbors;
		}
		PLTT_TraceList* get_traces()
		{
			return &traces;
		}
		PLTT_Node* get_self()
		{
			return &self;
		}
		void set_self( PLTT_Node _n )
		{
			self = _n;
		}
	private:
		Radio& radio()
		{
			return *radio_;
		}
		Timer& timer()
		{
			return *timer_;
		}
		Debug& debug()
		{
			return *debug_;
		}
		Rand& rand()
		{
			return *rand_;
		}
		Clock& clock()
		{
			return *clock_;
		}
		NeighborDiscovery& neighbor_discovery()
		{
			return *neighbor_discovery_;
		}
		Radio * radio_;
		Timer * timer_;
		Debug * debug_;
		Rand * rand_;
		Clock * clock_;
		NeighborDiscovery * neighbor_discovery_;
		enum MessageIds
		{
			PLTT_SPREAD_ID = 11,
			PLTT_INHIBITION_MESSAGE_ID = 21,
			PLTT_QUERY_ID = 31,
			PLTT_QUERY_REPORT_ID = 41,
			PLTT_TRACK_ECHO_ID = 51,
			PLTT_TRACK_ECHO_REPLY_ID = 61
		};
		uint32_t radio_callback_id_;
		uint32_t seconds_counter;
		PLTT_NodeList neighbors;
		PLTT_TraceList traces;
		PLTT_AgentList report_agents;
		PLTT_AgentList query_agents;
		PLTT_Node self;
		PLTT_SpreadMetrics spread_metrics;
		PLTT_TrackMetrics trace_metrics;
   	};
}
#endif
